import numpy as np
from graspy.simulations import sample_edges
import copy
import warnings

def sample_corr(P, Rho, directed=False, loops=False):
    """
    Generate a correlated Erdos-Renyi graph G2 based on G1 graph
    with Bernoulli distribution.

    Both G1 and G2 are binary matrices. 
    If the value of one position in graph 1 matrix is 1, 
    the probability of the same position of graph 2 to be 1 
    follows the Bernoulli distribution of
    (P[i][j])+Rho[i][j]*(1-P[i][j]).
    If the value of the position of graph 1 is 0, 
    the probability of the same position of graph 2 to be 1 
    follows the Bernoulli distribution of
    P1[i][j] = P[i][j]*(1-Rho[i][j]).

    Parameters
    ----------
    P: np.ndarray, shape (n_vertices, n_vertices)
        Matrix of probabilities (between 0 and 1) for a random graph
    Rho: np.ndarray, shape (n_vertices, n_vertices)
        Matrix whose elements are real numbers in the interval [0,1]
        Another probability matrix to definite the correlation between graph1 and graph2
    directed: boolean, optional (default=False)
        If False, output adjacency matrix will be symmetric. Otherwise, output adjacency
        matrix will be asymmetric.
    loops: boolean, optional (default=False)
        If False, no edges will be sampled in the diagonal. Otherwise, edges
        are sampled in the diagonal.

    References
    ----------
    .. [1] Vince Lyzinski, et al. "Seeded Graph Matching for Correlated Erd}os-Renyi Graphs", 
        Journal of Machine Learning Research 15, 2014
        
    Returns
    -------
    G1: ndarray (n_vertices, n_vertices)
        Binary matrix the same size as P representing a random graph,
        generated by the function of sample_edges
    G2: ndarray (n_vertices, n_vertices)
        Binary matrix the same size as P representing a random graph,
        based on correlation matrix with P and Rho

    Examples
    --------
    >>> p = 0.5
    >>> rho = 0.3
    >>> P = p * np.ones((5,5))
    >>> Rho = rho * np.ones((5,5))

    To sample a correlated graph based on P and Rho matrices:

    >>> sample_corr(P,Rho,directed = False, loops = False)
    array([[0. 1. 1. 0. 0.]
           [1. 0. 0. 1. 1.]
           [1. 0. 0. 1. 0.]
           [0. 1. 1. 0. 1.]
           [0. 1. 0. 1. 0.]]
          [[0. 0. 1. 1. 0.]
           [0. 0. 0. 1. 0.]
           [1. 0. 0. 0. 0.]
           [1. 1. 0. 0. 1.]
           [0. 0. 0. 1. 0.]])
    """

    n = np.size(P,1)
    G1 = sample_edges(P, directed = False, loops = False)
    origin_G1 = copy.deepcopy(G1)
    # prob1 = origin_G1.sum()/n**2

    P1 = copy.deepcopy(P)
    Rho = copy.deepcopy(Rho)
    for i in range(n):
        for j in range(n):
            if G1[i][j] == 1:
                P1[i][j] = P[i][j]+Rho[i][j]*(1-P[i][j])
            else:
                P1[i][j] = P[i][j]*(1-Rho[i][j])
    # prob2 = P1.sum()/n**2
    
    G2 = sample_edges(P1, directed = False, loops = False)
    G2 = G2 - np.diag(np.diag(G2))
    # prob3 = G2.sum()/(n*(n-1))
    return G1, G2

