<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>graspologic.simulations.simulations &mdash; graspologic 3.3.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=1cc24756"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            graspologic
          </a>
              <div class="version">
                3.3.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/install.html">Install</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/install.html#install-the-released-version">Install the released version</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/install.html#python-package-dependencies">Python package dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/install.html#hardware-requirements">Hardware requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/install.html#os-requirements">OS Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/install.html#testing">Testing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/cli.html">CLI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/contributing.html">Contributing to graspologic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/in-the-wild.html">graspologic in the wild</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/in-the-wild.html#papers">Papers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/in-the-wild.html#educational-materials">Educational materials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/in-the-wild.html#blog-posts">Blog posts</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/release.html">Release Log</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/release.html#graspologic-3-3-0">graspologic 3.3.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/release.html#graspologic-3-2-0">graspologic 3.2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/release.html#graspologic-3-1-0">graspologic 3.1.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/release.html#graspologic-3-0-0">graspologic 3.0.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/release.html#graspologic-2-0-1">graspologic 2.0.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/release.html#graspologic-2-0-0">graspologic 2.0.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/release.html#graspologic-1-0-0">graspologic 1.0.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/release.html#graspologic-0-3-0">graspologic 0.3.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/release.html#graspologic-0-2-0">graspologic 0.2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/release.html#graspologic-0-1-0">graspologic 0.1.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/release.html#previous-graspy-releases">Previous GraSPy Releases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/release/graspy_releases.html">GraSPy Release Log</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/reference/index.html">Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/reference/align.html">Aligning</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/align.html#sign-flips">Sign flips</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/align.html#orthogonal-procrustes">Orthogonal Procrustes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/align.html#seedless-procrustes">Seedless Procrustes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/reference/cluster.html">Clustering</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/cluster.html#k-means-clustering">K-Means Clustering</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/cluster.html#gaussian-mixture-models-clustering">Gaussian Mixture Models Clustering</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/cluster.html#hierarchical-clustering">Hierarchical Clustering</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/reference/datasets.html">Datasets</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/datasets.html#drosophila-larval-mushroom-body">Drosophila larval mushroom body</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/datasets.html#duke-mouse-whole-brain-connectomes">Duke mouse whole-brain connectomes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/reference/embed.html">Embedding</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/embed.html#decomposition">Decomposition</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/embed.html#single-graph-embedding">Single graph embedding</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/embed.html#multiple-graph-embedding">Multiple graph embedding</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/embed.html#dissimilarity-graph-embedding">Dissimilarity graph embedding</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/reference/inference.html">Inference</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/inference.html#two-graph-hypothesis-testing">Two-graph hypothesis testing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/reference/layouts.html">Layouts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/layouts.html#nodeposition">NodePosition</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/layouts.html#automatic-graph-layout">Automatic Graph Layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/layouts.html#colors">Colors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/layouts.html#rendering">Rendering</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/reference/match.html">Matching</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/match.html#graph-matching">Graph Matching</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/reference/models.html">Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/models.html#erdos-reyni-models">Erdos-Reyni models</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/models.html#stochastic-block-models">Stochastic block models</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/models.html#latent-position-models">Latent position models</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/models.html#edge-swapping-configuration-models">Edge swapping (configuration models)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/reference/nominate.html">Nomination</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/nominate.html#spectral-vertex-nomination">Spectral Vertex Nomination</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/nominate.html#vertex-nomination-via-sgm">Vertex Nomination via SGM</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/reference/partition.html">Partition</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/partition.html#modularity-and-component-modularity">Modularity and Component Modularity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/partition.html#leiden-and-hierarchical-leiden">Leiden and Hierarchical Leiden</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/reference/preconditions.html">Preconditions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/preconditions.html#graspologic.preconditions.check_argument_types"><code class="docutils literal notranslate"><span class="pre">check_argument_types()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/preconditions.html#graspologic.preconditions.check_optional_argument_types"><code class="docutils literal notranslate"><span class="pre">check_optional_argument_types()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/preconditions.html#graspologic.preconditions.check_argument"><code class="docutils literal notranslate"><span class="pre">check_argument()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/preconditions.html#graspologic.preconditions.is_real_weighted"><code class="docutils literal notranslate"><span class="pre">is_real_weighted()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/reference/pipeline.html">Pipeline</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/pipeline.html#graphbuilder">GraphBuilder</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/pipeline.html#module-graspologic.pipeline.embed">Embed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/reference/plotting.html">Plotting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/plotting.html#heatmap">Heatmap</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/plotting.html#gridplot">Gridplot</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/plotting.html#pairplot">Pairplot</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/plotting.html#degreeplot">Degreeplot</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/plotting.html#edgeplot">Edgeplot</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/plotting.html#screeplot">Screeplot</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/plotting.html#adjplot">Adjplot</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/plotting.html#matrixplot">Matrixplot</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/reference/preprocessing.html">Preprocessing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/preprocessing.html#graph-cuts">Graph Cuts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/reference/simulations.html">Simulations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/simulations.html#graspologic.simulations.er_np"><code class="docutils literal notranslate"><span class="pre">er_np()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/simulations.html#graspologic.simulations.er_nm"><code class="docutils literal notranslate"><span class="pre">er_nm()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/simulations.html#graspologic.simulations.sbm"><code class="docutils literal notranslate"><span class="pre">sbm()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/simulations.html#graspologic.simulations.rdpg"><code class="docutils literal notranslate"><span class="pre">rdpg()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/simulations.html#graspologic.simulations.er_corr"><code class="docutils literal notranslate"><span class="pre">er_corr()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/simulations.html#graspologic.simulations.sbm_corr"><code class="docutils literal notranslate"><span class="pre">sbm_corr()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/simulations.html#graspologic.simulations.rdpg_corr"><code class="docutils literal notranslate"><span class="pre">rdpg_corr()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/simulations.html#graspologic.simulations.mmsbm"><code class="docutils literal notranslate"><span class="pre">mmsbm()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/reference/subgraph.html">Subgraph</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/subgraph.html#signal-subgraph-estimators">Signal-Subgraph Estimators</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/reference/utils.html">Utility</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/utils.html#transformations">Transformations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/utils.html#connected-components">Connected Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/utils.html#io">IO</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/reference/utils.html#other">Other</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/index.html#models">Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/models/models.html">Random Graph Models</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/models/edge_swaps.html">Degree Preserving Edge Swaps</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/index.html#simulations">Simulations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/simulations/erdos_renyi.html">Erdos-Renyi (ER) Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/simulations/sbm.html">Stochastic Block Model (SBM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/simulations/mmsbm.html">Mixed Membership Stochastic Blockmodel (MMSBM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/simulations/rdpg.html">Random Dot Product Graph (RDPG) Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/simulations/corr.html">Correlated Graph Pairs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/simulations/rdpg_corr.html">Correlated Random Dot Product Graph (RDPG) Graph Pair</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/index.html#clustering">Clustering</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/clustering/autogmm.html">Automatic Gaussian Mixture Modeling</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/clustering/kclust.html">K-Means Clustering</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/index.html#embedding">Embedding</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/embedding/AdjacencySpectralEmbed.html">Adjacency Spectral Embed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/embedding/OutOfSampleEmbed.html">Out-of-Sample (OOS) Embedding</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/embedding/CovariateAssistedEmbed.html">Covariate-Assisted Embedding</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/embedding/MASE.html">Multiple Adjacency Spectral Embedding (MASE)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/embedding/Omnibus.html">Omnibus Embedding for Multiple Graphs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/index.html#inference">Inference</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/inference/density_test.html">Testing Symmetry of Two Networks with the Density Test</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/inference/density_test.html#Performing-the-Density-Test">Performing the Density Test</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/inference/group_connection_test.html">Group connection test</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/inference/latent_position_test.html">Latent Position Two-Graph Testing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/inference/latent_distribution_test.html">Latent Distribution Two-Graph Testing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/index.html#plotting">Plotting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/plotting/heatmaps.html">Heatmap: Visualizing a Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/plotting/gridplot.html">Gridplot: Visualize Multiple Graphs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/plotting/pairplot.html">Pairplot: Visualizing High Dimensional Data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/plotting/matrixplot.html">Matrixplot and Adjplot: Visualize and sort matrices with metadata</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/plotting/pairplot_with_gmm.html">Pairplot with GMM: Visualizing High Dimensional Data and Clustering</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/plotting/networkplot.html">Networkplot: Visualizing 2D Layouts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/index.html#matching">Matching</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/matching/faq.html">Introduction to Graph Matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/matching/sgm.html">Seeded Graph Matching (SGM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/matching/padded_gm.html">Padded Graph Matching</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/index.html#subgraph">Subgraph</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/subgraph/subgraph.html">Signal Subgraph Estimators</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/index.html#vertex-nomination">Vertex Nomination</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/vertex_nomination/SpectralVertexNomination.html">Spectral Vertex Nomination</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/nominate/vertex_nomination_via_SGM.html">Nomination via SGM</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/index.html#aligning">Aligning</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/aligning/aligning.html">Aligning</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/index.html#connectomics">Connectomics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tutorials/connectomics/mcc.html">Methods for Multiscale Comparative Connectomics</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Useful Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="http://www.github.com/microsoft/graspologic/">graspologic &#64; GitHub</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pypi.org/project/graspologic/">graspologic &#64; PyPI</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/microsoft/graspologic/issues">Issue Tracker</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">graspologic</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">graspologic.simulations.simulations</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for graspologic.simulations.simulations</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) Microsoft Corporation and contributors.</span>
<span class="c1"># Licensed under the MIT License.</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">sklearn.utils</span> <span class="kn">import</span> <span class="n">check_array</span><span class="p">,</span> <span class="n">check_scalar</span>

<span class="kn">from</span> <span class="nn">graspologic.types</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">cartesian_product</span><span class="p">,</span> <span class="n">symmetrize</span>


<span class="k">def</span> <span class="nf">_n_to_labels</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">n_cumsum</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
        <span class="n">labels</span><span class="p">[</span><span class="n">n_cumsum</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="p">:</span> <span class="n">n_cumsum</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">return</span> <span class="n">labels</span>


<span class="k">def</span> <span class="nf">sample_edges</span><span class="p">(</span>
    <span class="n">P</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">loops</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gemerates a binary random graph based on the P matrix provided</span>

<span class="sd">    Each element in P represents the probability of a connection between</span>
<span class="sd">    a vertex indexed by the row i and the column j.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    P: np.ndarray, shape (n_vertices, n_vertices)</span>
<span class="sd">        Matrix of probabilities (between 0 and 1) for a random graph</span>
<span class="sd">    directed: boolean, optional (default=False)</span>
<span class="sd">        If False, output adjacency matrix will be symmetric. Otherwise, output adjacency</span>
<span class="sd">        matrix will be asymmetric.</span>
<span class="sd">    loops: boolean, optional (default=False)</span>
<span class="sd">        If False, no edges will be sampled in the diagonal. Otherwise, edges</span>
<span class="sd">        are sampled in the diagonal.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A: ndarray (n_vertices, n_vertices)</span>
<span class="sd">        Binary adjacency matrix the same size as P representing a random</span>
<span class="sd">        graph</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Sussman, D.L., Tang, M., Fishkind, D.E., Priebe, C.E.  &quot;A</span>
<span class="sd">       Consistent Adjacency Spectral Embedding for Stochastic Blockmodel Graphs,&quot;</span>
<span class="sd">       Journal of the American Statistical Association, Vol. 107(499), 2012</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;P must be numpy.ndarray&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;P must have dimension 2 (n_vertices, n_dimensions)&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;P must be a square matrix&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">directed</span><span class="p">:</span>
        <span class="c1"># can cut down on sampling by ~half</span>
        <span class="n">triu_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">P</span><span class="p">[</span><span class="n">triu_inds</span><span class="p">])</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
        <span class="n">A</span><span class="p">[</span><span class="n">triu_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">symmetrize</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;triu&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">loops</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">A</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">A</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>


<div class="viewcode-block" id="er_np"><a class="viewcode-back" href="../../../reference/reference/simulations.html#graspologic.simulations.er_np">[docs]</a><span class="k">def</span> <span class="nf">er_np</span><span class="p">(</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">loops</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">wt</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">wtargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dc_kws</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Samples a Erdos Renyi (n, p) graph with specified edge probability.</span>

<span class="sd">    Erdos Renyi (n, p) graph is a simple graph with n vertices and a probability</span>
<span class="sd">    p of edges being connected.</span>

<span class="sd">    Read more in the `Erdos-Renyi (ER) Model Tutorial</span>
<span class="sd">    &lt;https://microsoft.github.io/graspologic/tutorials/simulations/erdos_renyi.html&gt;`_</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n: int</span>
<span class="sd">       Number of vertices</span>

<span class="sd">    p: float</span>
<span class="sd">        Probability of an edge existing between two vertices, between 0 and 1.</span>

<span class="sd">    directed: boolean, optional (default=False)</span>
<span class="sd">        If False, output adjacency matrix will be symmetric. Otherwise, output adjacency</span>
<span class="sd">        matrix will be asymmetric.</span>

<span class="sd">    loops: boolean, optional (default=False)</span>
<span class="sd">        If False, no edges will be sampled in the diagonal. Otherwise, edges</span>
<span class="sd">        are sampled in the diagonal.</span>

<span class="sd">    wt: object, optional (default=1)</span>
<span class="sd">        Weight function for each of the edges, taking only a size argument.</span>
<span class="sd">        This weight function will be randomly assigned for selected edges.</span>
<span class="sd">        If 1, graph produced is binary.</span>

<span class="sd">    wtargs: dictionary, optional (default=None)</span>
<span class="sd">        Optional arguments for parameters that can be passed</span>
<span class="sd">        to weight function ``wt``.</span>

<span class="sd">    dc: function or array-like, shape (n_vertices)</span>
<span class="sd">        ``dc`` is used to generate a degree-corrected Erdos Renyi Model in</span>
<span class="sd">        which each node in the graph has a parameter to specify its expected degree</span>
<span class="sd">        relative to other nodes.</span>

<span class="sd">        - function:</span>
<span class="sd">            should generate a non-negative number to be used as a degree correction to</span>
<span class="sd">            create a heterogenous degree distribution. A weight will be generated for</span>
<span class="sd">            each vertex, normalized so that the sum of weights is 1.</span>
<span class="sd">        - array-like of scalars, shape (n_vertices):</span>
<span class="sd">            The weights should sum to 1; otherwise, they will be</span>
<span class="sd">            normalized and a warning will be thrown. The scalar associated with each</span>
<span class="sd">            vertex is the node&#39;s relative expected degree.</span>

<span class="sd">    dc_kws: dictionary</span>
<span class="sd">        Ignored if ``dc`` is none or array of scalar.</span>
<span class="sd">        If ``dc`` is a function, ``dc_kws`` corresponds to its named arguments.</span>
<span class="sd">        If not specified, in either case all functions will assume their default</span>
<span class="sd">        parameters.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : ndarray, shape (n, n)</span>
<span class="sd">        Sampled adjacency matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.random.seed(1)</span>
<span class="sd">    &gt;&gt;&gt; n = 4</span>
<span class="sd">    &gt;&gt;&gt; p = 0.25</span>

<span class="sd">    To sample a binary Erdos Renyi (n, p) graph:</span>

<span class="sd">    &gt;&gt;&gt; er_np(n, p)</span>
<span class="sd">    array([[0., 0., 1., 0.],</span>
<span class="sd">           [0., 0., 1., 0.],</span>
<span class="sd">           [1., 1., 0., 0.],</span>
<span class="sd">           [0., 0., 0., 0.]])</span>

<span class="sd">    To sample a weighted Erdos Renyi (n, p) graph with Uniform(0, 1) distribution:</span>

<span class="sd">    &gt;&gt;&gt; wt = np.random.uniform</span>
<span class="sd">    &gt;&gt;&gt; wtargs = dict(low=0, high=1)</span>
<span class="sd">    &gt;&gt;&gt; er_np(n, p, wt=wt, wtargs=wtargs)</span>
<span class="sd">    array([[0.        , 0.        , 0.95788953, 0.53316528],</span>
<span class="sd">           [0.        , 0.        , 0.        , 0.        ],</span>
<span class="sd">           [0.95788953, 0.        , 0.        , 0.31551563],</span>
<span class="sd">           [0.53316528, 0.        , 0.31551563, 0.        ]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">callable</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">dc</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;dc is not of type function or array-like of scalars&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;n is not of type int.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;p is not of type float.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">loops</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;loops is not of type bool.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">directed</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;directed is not of type bool.&quot;</span><span class="p">)</span>
    <span class="n">n_sbm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span><span class="p">])</span>
    <span class="n">p_sbm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">p</span><span class="p">]])</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">sbm</span><span class="p">(</span><span class="n">n_sbm</span><span class="p">,</span> <span class="n">p_sbm</span><span class="p">,</span> <span class="n">directed</span><span class="p">,</span> <span class="n">loops</span><span class="p">,</span> <span class="n">wt</span><span class="p">,</span> <span class="n">wtargs</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">dc_kws</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span>  <span class="c1"># type: ignore</span></div>


<div class="viewcode-block" id="er_nm"><a class="viewcode-back" href="../../../reference/reference/simulations.html#graspologic.simulations.er_nm">[docs]</a><span class="k">def</span> <span class="nf">er_nm</span><span class="p">(</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">loops</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">wt</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">wtargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Samples an Erdos Renyi (n, m) graph with specified number of edges.</span>

<span class="sd">    Erdos Renyi (n, m) graph is a simple graph with n vertices and exactly m</span>
<span class="sd">    number of total edges.</span>

<span class="sd">    Read more in the `Erdos-Renyi (ER) Model Tutorial</span>
<span class="sd">    &lt;https://microsoft.github.io/graspologic/tutorials/simulations/erdos_renyi.html&gt;`_</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n: int</span>
<span class="sd">        Number of vertices</span>

<span class="sd">    m: int</span>
<span class="sd">        Number of edges, a value between 1 and :math:`n^2`.</span>

<span class="sd">    directed: boolean, optional (default=False)</span>
<span class="sd">        If False, output adjacency matrix will be symmetric. Otherwise, output adjacency</span>
<span class="sd">        matrix will be asymmetric.</span>

<span class="sd">    loops: boolean, optional (default=False)</span>
<span class="sd">        If False, no edges will be sampled in the diagonal. Otherwise, edges</span>
<span class="sd">        are sampled in the diagonal.</span>

<span class="sd">    wt: object, optional (default=1)</span>
<span class="sd">        Weight function for each of the edges, taking only a size argument.</span>
<span class="sd">        This weight function will be randomly assigned for selected edges.</span>
<span class="sd">        If 1, graph produced is binary.</span>

<span class="sd">    wtargs: dictionary, optional (default=None)</span>
<span class="sd">        Optional arguments for parameters that can be passed</span>
<span class="sd">        to weight function ``wt``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A: ndarray, shape (n, n)</span>
<span class="sd">        Sampled adjacency matrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.random.seed(1)</span>
<span class="sd">    &gt;&gt;&gt; n = 4</span>
<span class="sd">    &gt;&gt;&gt; m = 4</span>

<span class="sd">    To sample a binary Erdos Renyi (n, m) graph:</span>

<span class="sd">    &gt;&gt;&gt; er_nm(n, m)</span>
<span class="sd">    array([[0., 1., 1., 1.],</span>
<span class="sd">           [1., 0., 0., 1.],</span>
<span class="sd">           [1., 0., 0., 0.],</span>
<span class="sd">           [1., 1., 0., 0.]])</span>

<span class="sd">    To sample a weighted Erdos Renyi (n, m) graph with Uniform(0, 1) distribution:</span>

<span class="sd">    &gt;&gt;&gt; wt = np.random.uniform</span>
<span class="sd">    &gt;&gt;&gt; wtargs = dict(low=0, high=1)</span>
<span class="sd">    &gt;&gt;&gt; er_nm(n, m, wt=wt, wtargs=wtargs)</span>
<span class="sd">    array([[0.        , 0.66974604, 0.        , 0.38791074],</span>
<span class="sd">           [0.66974604, 0.        , 0.        , 0.39658073],</span>
<span class="sd">           [0.        , 0.        , 0.        , 0.93553907],</span>
<span class="sd">           [0.38791074, 0.39658073, 0.93553907, 0.        ]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;m is not of type int.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;m must be &gt; 0.&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;n is not of type int.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;n must be &gt; 0.&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">directed</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;directed is not of type bool.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">loops</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;loops is not of type bool.&quot;</span><span class="p">)</span>

    <span class="c1"># check weight function</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">wt</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">wt</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;You have not passed a function for wt.&quot;</span><span class="p">)</span>

    <span class="c1"># compute max number of edges to sample</span>
    <span class="k">if</span> <span class="n">loops</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">directed</span><span class="p">:</span>
            <span class="n">max_edges</span> <span class="o">=</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;n^2&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_edges</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;n(n+1)/2&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">directed</span><span class="p">:</span>
            <span class="n">max_edges</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;n(n-1)&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_edges</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;n(n-1)/2&quot;</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">max_edges</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;You have passed a number of edges, </span><span class="si">{}</span><span class="s2">, exceeding </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">.&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">max_edges</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="c1"># check if directedness is desired</span>
    <span class="k">if</span> <span class="n">directed</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">loops</span><span class="p">:</span>
            <span class="c1"># use all of the indices</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># use only the off-diagonal indices</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># use upper-triangle indices, and ignore diagonal according</span>
        <span class="c1"># to loops argument</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">loops</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">))</span>

    <span class="c1"># get idx in 1d coordinates by ravelling</span>
    <span class="n">triu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># choose M of them</span>
    <span class="n">triu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">triu</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># unravel back</span>
    <span class="n">_triu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">triu</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># check weight function</span>
    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">wt</span><span class="p">):</span>
        <span class="n">wt</span> <span class="o">=</span> <span class="n">wt</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="o">**</span><span class="n">wtargs</span><span class="p">)</span>
    <span class="n">A</span><span class="p">[</span><span class="n">_triu</span><span class="p">]</span> <span class="o">=</span> <span class="n">wt</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">directed</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">symmetrize</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;triu&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">A</span></div>


<div class="viewcode-block" id="sbm"><a class="viewcode-back" href="../../../reference/reference/simulations.html#graspologic.simulations.sbm">[docs]</a><span class="k">def</span> <span class="nf">sbm</span><span class="p">(</span>
    <span class="n">n</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">loops</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">wt</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">wtargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dc_kws</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">return_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Samples a graph from the stochastic block model (SBM).</span>

<span class="sd">    SBM produces a graph with specified communities, in which each community can</span>
<span class="sd">    have different sizes and edge probabilities.</span>

<span class="sd">    Read more in the `Stochastic Block Model (SBM) Tutorial</span>
<span class="sd">    &lt;https://microsoft.github.io/graspologic/tutorials/simulations/sbm.html&gt;`_</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n: list of int, shape (n_communities)</span>
<span class="sd">        Number of vertices in each community. Communities are assigned n[0], n[1], ...</span>

<span class="sd">    p: array-like, shape (n_communities, n_communities)</span>
<span class="sd">        Probability of an edge between each of the communities, where ``p[i, j]`` indicates</span>
<span class="sd">        the probability of a connection between edges in communities ``[i, j]``.</span>
<span class="sd">        ``0 &lt; p[i, j] &lt; 1`` for all ``i, j``.</span>

<span class="sd">    directed: boolean, optional (default=False)</span>
<span class="sd">        If False, output adjacency matrix will be symmetric. Otherwise, output adjacency</span>
<span class="sd">        matrix will be asymmetric.</span>

<span class="sd">    loops: boolean, optional (default=False)</span>
<span class="sd">        If False, no edges will be sampled in the diagonal. Otherwise, edges</span>
<span class="sd">        are sampled in the diagonal.</span>

<span class="sd">    wt: object or array-like, shape (n_communities, n_communities)</span>
<span class="sd">        if ``wt`` is an object, a weight function to use globally over</span>
<span class="sd">        the sbm for assigning weights. 1 indicates to produce a binary</span>
<span class="sd">        graph. If ``wt`` is an array-like, a weight function for each of</span>
<span class="sd">        the edge communities. ``wt[i, j]`` corresponds to the weight function</span>
<span class="sd">        between communities i and j. If the entry is a function, should</span>
<span class="sd">        accept an argument for size. An entry of ``wt[i, j] = 1`` will produce a</span>
<span class="sd">        binary subgraph over the i, j community.</span>

<span class="sd">    wtargs: dictionary or array-like, shape (n_communities, n_communities)</span>
<span class="sd">        if ``wt`` is an object, ``wtargs`` corresponds to the trailing arguments</span>
<span class="sd">        to pass to the weight function. If Wt is an array-like, ``wtargs[i, j]``</span>
<span class="sd">        corresponds to trailing arguments to pass to ``wt[i, j]``.</span>

<span class="sd">    dc: function or array-like, shape (n_vertices) or (n_communities), optional</span>
<span class="sd">        ``dc`` is used to generate a degree-corrected stochastic block model [1] in</span>
<span class="sd">        which each node in the graph has a parameter to specify its expected degree</span>
<span class="sd">        relative to other nodes within its community.</span>

<span class="sd">        - function:</span>
<span class="sd">            should generate a non-negative number to be used as a degree correction to</span>
<span class="sd">            create a heterogenous degree distribution. A weight will be generated for</span>
<span class="sd">            each vertex, normalized so that the sum of weights in each block is 1.</span>
<span class="sd">        - array-like of functions, shape (n_communities):</span>
<span class="sd">            Each function will generate the degree distribution for its respective</span>
<span class="sd">            community.</span>
<span class="sd">        - array-like of scalars, shape (n_vertices):</span>
<span class="sd">            The weights in each block should sum to 1; otherwise, they will be</span>
<span class="sd">            normalized and a warning will be thrown. The scalar associated with each</span>
<span class="sd">            vertex is the node&#39;s relative expected degree within its community.</span>

<span class="sd">    dc_kws: dictionary or array-like, shape (n_communities), optional</span>
<span class="sd">        Ignored if ``dc`` is none or array of scalar.</span>
<span class="sd">        If ``dc`` is a function, ``dc_kws`` corresponds to its named arguments.</span>
<span class="sd">        If ``dc`` is an array-like of functions, ``dc_kws`` should be an array-like, shape</span>
<span class="sd">        (n_communities), of dictionary. Each dictionary is the named arguments</span>
<span class="sd">        for the corresponding function for that community.</span>
<span class="sd">        If not specified, in either case all functions will assume their default</span>
<span class="sd">        parameters.</span>

<span class="sd">    return_labels: boolean, optional (default=False)</span>
<span class="sd">        If False, only output is adjacency matrix. Otherwise, an additional output will</span>
<span class="sd">        be an array with length equal to the number of vertices in the graph, where each</span>
<span class="sd">        entry in the array labels which block a vertex in the graph is in.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Tai Qin and Karl Rohe. &quot;Regularized spectral clustering under the</span>
<span class="sd">        Degree-Corrected Stochastic Blockmodel,&quot; Advances in Neural Information</span>
<span class="sd">        Processing Systems 26, 2013</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A: ndarray, shape (sum(n), sum(n))</span>
<span class="sd">        Sampled adjacency matrix</span>
<span class="sd">    labels: ndarray, shape (sum(n))</span>
<span class="sd">        Label vector</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.random.seed(1)</span>
<span class="sd">    &gt;&gt;&gt; n = [3, 3]</span>
<span class="sd">    &gt;&gt;&gt; p = [[0.5, 0.1], [0.1, 0.5]]</span>

<span class="sd">    To sample a binary 2-block SBM graph:</span>

<span class="sd">    &gt;&gt;&gt; sbm(n, p)</span>
<span class="sd">    array([[0., 0., 1., 0., 0., 0.],</span>
<span class="sd">           [0., 0., 1., 0., 0., 1.],</span>
<span class="sd">           [1., 1., 0., 0., 0., 0.],</span>
<span class="sd">           [0., 0., 0., 0., 1., 0.],</span>
<span class="sd">           [0., 0., 0., 1., 0., 0.],</span>
<span class="sd">           [0., 1., 0., 0., 0., 0.]])</span>

<span class="sd">    To sample a weighted 2-block SBM graph with Poisson(2) distribution:</span>

<span class="sd">    &gt;&gt;&gt; wt = np.random.poisson</span>
<span class="sd">    &gt;&gt;&gt; wtargs = dict(lam=2)</span>
<span class="sd">    &gt;&gt;&gt; sbm(n, p, wt=wt, wtargs=wtargs)</span>
<span class="sd">    array([[0., 4., 0., 1., 0., 0.],</span>
<span class="sd">           [4., 0., 0., 0., 0., 2.],</span>
<span class="sd">           [0., 0., 0., 0., 0., 0.],</span>
<span class="sd">           [1., 0., 0., 0., 0., 0.],</span>
<span class="sd">           [0., 0., 0., 0., 0., 0.],</span>
<span class="sd">           [0., 2., 0., 0., 0., 0.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check n</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;n must be a list or np.array, not </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;There are non-integer elements in n&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># Check p</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;p must be a list or np.array, not </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;There are non-numeric elements in p&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;p must have shape len(n) x len(n), not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Values in p must be in between 0 and 1.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># Check wt and wtargs</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">wt</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">wt</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wt</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;wt must be a numeric, list, or np.array, not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">wt</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wtargs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;wtargs must be a numeric, list, or np.array, not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">wtargs</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">wt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">wt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">wtargs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">wtargs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="c1"># if not number, check dimensions</span>
        <span class="k">if</span> <span class="n">wt</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;wt must have size len(n) x len(n), not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">wt</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wtargs</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;wtargs must have size len(n) x len(n), not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">wtargs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># check if each element is a function</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">wt</span><span class="o">.</span><span class="n">ravel</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not a callable function.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">wt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">wt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">wtargs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">wtargs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

    <span class="c1"># Check directed</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">directed</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">p</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Specified undirected, but P is directed.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">wt</span> <span class="o">!=</span> <span class="n">wt</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Specified undirected, but Wt is directed.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">wtargs</span> <span class="o">!=</span> <span class="n">wtargs</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Specified undirected, but Wtargs is directed.&quot;</span><span class="p">)</span>

    <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>  <span class="c1"># the number of communities</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># get a list of community indices</span>
    <span class="n">cmties</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
        <span class="n">cmties</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">counter</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># Check degree-corrected input parameters</span>
    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">dc</span><span class="p">):</span>
        <span class="c1"># Check that the paramters are a dict</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dc_kws</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;dc_kws must be of type dict not</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dc_kws</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Create the probability matrix for each vertex</span>
        <span class="n">dcProbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dc</span><span class="p">(</span><span class="o">**</span><span class="n">dc_kws</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n</span><span class="p">))],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">cmties</span><span class="p">:</span>
            <span class="n">dcProbs</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">/=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dcProbs</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dc</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span>
    <span class="p">):</span>
        <span class="n">dcProbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># Check size and element types</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dcProbs</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;There are non-numeric elements in dc, </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dcProbs</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dcProbs</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">n</span><span class="p">),):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;dc must have size equal to the number of&quot;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot; vertices </span><span class="si">{0}</span><span class="s2">, not </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">dcProbs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dcProbs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Values in dc cannot be negative.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Check that probabilities sum to 1 in each block</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">dcProbs</span><span class="p">[</span><span class="n">cmties</span><span class="p">[</span><span class="n">i</span><span class="p">]]),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1.0e-8</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Block </span><span class="si">{}</span><span class="s2"> probabilities should sum to 1, normalizing...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
                <span class="n">dcProbs</span><span class="p">[</span><span class="n">cmties</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">/=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dcProbs</span><span class="p">[</span><span class="n">cmties</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">callable</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">dc</span><span class="p">):</span>
        <span class="n">dcFuncs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dcFuncs</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">),):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;dc must have size equal to the number of blocks </span><span class="si">{0}</span><span class="s2">, not </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">dcFuncs</span><span class="o">.</span><span class="n">shape</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Check that the parameters type, length, and type</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dc_kws</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="c1"># Allows for nonspecification of default parameters for all functions</span>
            <span class="k">if</span> <span class="n">dc_kws</span> <span class="o">==</span> <span class="p">{}:</span>
                <span class="n">dc_kws</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">))]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;dc_kws must be of type list or np.ndarray, not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">dc_kws</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">dc_kws</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;dc_kws must have size equal to&quot;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot; the number of blocks </span><span class="si">{0}</span><span class="s2">, not </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">dc_kws</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span> <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">dc_kws</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;dc_kws elements must all be of type dict&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Create the probability matrix for each vertex</span>
        <span class="n">dcProbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">dcFunc</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">dcFunc</span><span class="p">,</span> <span class="n">kws</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dcFuncs</span><span class="p">,</span> <span class="n">dc_kws</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
            <span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># dcProbs = dcProbs.astype(float)</span>
        <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">cmties</span><span class="p">:</span>
            <span class="n">dcProbs</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">/=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dcProbs</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
            <span class="c1"># dcProbs[indices] = dcProbs / dcProbs[indices].sum()</span>
    <span class="k">elif</span> <span class="n">dc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;dc must be a function or a list or np.array of numbers or callable&quot;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot; functions, not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dc</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># End Checks, begin simulation</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">sum</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">directed</span><span class="p">:</span>
            <span class="n">jrange</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">jrange</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">jrange</span><span class="p">:</span>
            <span class="n">block_wt</span> <span class="o">=</span> <span class="n">wt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">block_wtargs</span> <span class="o">=</span> <span class="n">wtargs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">block_p</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="c1"># identify submatrix for community i, j</span>
            <span class="c1"># cartesian product to identify edges for community i,j pair</span>
            <span class="n">cprod</span> <span class="o">=</span> <span class="n">cartesian_product</span><span class="p">(</span><span class="n">cmties</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmties</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>  <span class="c1"># type: ignore</span>
            <span class="c1"># get idx in 1d coordinates by ravelling</span>
            <span class="n">triu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">((</span><span class="n">cprod</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cprod</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">pchoice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">triu</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">dc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># (v1,v2) connected with probability p*k_i*k_j*dcP[v1]*dcP[v2]</span>
                <span class="n">num_edges</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pchoice</span> <span class="o">&lt;</span> <span class="n">block_p</span><span class="p">)</span>
                <span class="n">edge_dist</span> <span class="o">=</span> <span class="n">dcProbs</span><span class="p">[</span><span class="n">cprod</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">dcProbs</span><span class="p">[</span><span class="n">cprod</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span>
                <span class="c1"># If n_edges greater than support of dc distribution, pick fewer edges</span>
                <span class="k">if</span> <span class="n">num_edges</span> <span class="o">&gt;</span> <span class="nb">sum</span><span class="p">(</span><span class="n">edge_dist</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;More edges sampled than nonzero pairwise dc entries.&quot;</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot; Picking fewer edges&quot;</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
                    <span class="n">num_edges</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">edge_dist</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">triu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                    <span class="n">triu</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">num_edges</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">edge_dist</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># connected with probability p</span>
                <span class="n">triu</span> <span class="o">=</span> <span class="n">triu</span><span class="p">[</span><span class="n">pchoice</span> <span class="o">&lt;</span> <span class="n">block_p</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">block_wt</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">:</span>
                <span class="n">block_wt</span> <span class="o">=</span> <span class="n">block_wt</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">triu</span><span class="p">),</span> <span class="o">**</span><span class="n">block_wtargs</span><span class="p">)</span>
            <span class="n">_triu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">triu</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">A</span><span class="p">[</span><span class="n">_triu</span><span class="p">]</span> <span class="o">=</span> <span class="n">block_wt</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">loops</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">directed</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">symmetrize</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;triu&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_labels</span><span class="p">:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">_n_to_labels</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="n">labels</span>
    <span class="k">return</span> <span class="n">A</span></div>


<div class="viewcode-block" id="rdpg"><a class="viewcode-back" href="../../../reference/reference/simulations.html#graspologic.simulations.rdpg">[docs]</a><span class="k">def</span> <span class="nf">rdpg</span><span class="p">(</span>
    <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">Y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">rescale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">loops</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">wt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">wtargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Samples a random graph based on the latent positions in X (and</span>
<span class="sd">    optionally in Y)</span>

<span class="sd">    If only X :math:`\in\mathbb{R}^{n\times d}` is given, the P matrix is calculated as</span>
<span class="sd">    :math:`P = XX^T`. If X, Y :math:`\in\mathbb{R}^{n\times d}` is given, then</span>
<span class="sd">    :math:`P = XY^T`. These operations correspond to the dot products between a set of</span>
<span class="sd">    latent positions, so each row in X or Y represents the latent positions in</span>
<span class="sd">    :math:`\mathbb{R}^{d}` for a single vertex in the random graph</span>
<span class="sd">    Note that this function may also rescale or clip the resulting P</span>
<span class="sd">    matrix to get probabilities between 0 and 1, or remove loops.</span>
<span class="sd">    A binary random graph is then sampled from the P matrix described</span>
<span class="sd">    by X (and possibly Y).</span>

<span class="sd">    Read more in the `Random Dot Product Graph (RDPG) Model Tutorial</span>
<span class="sd">    &lt;https://microsoft.github.io/graspologic/tutorials/simulations/rdpg.html&gt;`_</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X: np.ndarray, shape (n_vertices, n_dimensions)</span>
<span class="sd">        latent position from which to generate a P matrix</span>
<span class="sd">        if Y is given, interpreted as the left latent position</span>

<span class="sd">    Y: np.ndarray, shape (n_vertices, n_dimensions) or None, optional</span>
<span class="sd">        right latent position from which to generate a P matrix</span>

<span class="sd">    rescale: boolean, optional (default=False)</span>
<span class="sd">        when ``rescale`` is True, will subtract the minimum value in</span>
<span class="sd">        P (if it is below 0) and divide by the maximum (if it is</span>
<span class="sd">        above 1) to ensure that P has entries between 0 and 1. If</span>
<span class="sd">        False, elements of P outside of [0, 1] will be clipped</span>

<span class="sd">    directed: boolean, optional (default=False)</span>
<span class="sd">        If False, output adjacency matrix will be symmetric. Otherwise, output adjacency</span>
<span class="sd">        matrix will be asymmetric.</span>

<span class="sd">    loops: boolean, optional (default=False)</span>
<span class="sd">        If False, no edges will be sampled in the diagonal. Diagonal elements in P</span>
<span class="sd">        matrix are removed prior to rescaling (see above) which may affect behavior.</span>
<span class="sd">        Otherwise, edges are sampled in the diagonal.</span>

<span class="sd">    wt: object, optional (default=1)</span>
<span class="sd">        Weight function for each of the edges, taking only a size argument.</span>
<span class="sd">        This weight function will be randomly assigned for selected edges.</span>
<span class="sd">        If 1, graph produced is binary.</span>

<span class="sd">    wtargs: dictionary, optional (default=None)</span>
<span class="sd">        Optional arguments for parameters that can be passed</span>
<span class="sd">        to weight function ``wt``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A: ndarray (n_vertices, n_vertices)</span>
<span class="sd">        A matrix representing the probabilities of connections between</span>
<span class="sd">        vertices in a random graph based on their latent positions</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Sussman, D.L., Tang, M., Fishkind, D.E., Priebe, C.E.  &quot;A</span>
<span class="sd">       Consistent Adjacency Spectral Embedding for Stochastic Blockmodel Graphs,&quot;</span>
<span class="sd">       Journal of the American Statistical Association, Vol. 107(499), 2012</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.random.seed(1)</span>

<span class="sd">    Generate random latent positions using 2-dimensional Dirichlet distribution.</span>

<span class="sd">    &gt;&gt;&gt; X = np.random.dirichlet([1, 1], size=5)</span>

<span class="sd">    Sample a binary RDPG using sampled latent positions.</span>

<span class="sd">    &gt;&gt;&gt; rdpg(X, loops=False)</span>
<span class="sd">    array([[0., 1., 0., 0., 1.],</span>
<span class="sd">           [1., 0., 0., 1., 1.],</span>
<span class="sd">           [0., 0., 0., 1., 1.],</span>
<span class="sd">           [0., 1., 1., 0., 0.],</span>
<span class="sd">           [1., 1., 1., 0., 0.]])</span>

<span class="sd">    Sample a weighted RDPG with Poisson(2) weight distribution</span>

<span class="sd">    &gt;&gt;&gt; wt = np.random.poisson</span>
<span class="sd">    &gt;&gt;&gt; wtargs = dict(lam=2)</span>
<span class="sd">    &gt;&gt;&gt; rdpg(X, loops=False, wt=wt, wtargs=wtargs)</span>
<span class="sd">    array([[0., 4., 0., 2., 0.],</span>
<span class="sd">           [1., 0., 0., 0., 0.],</span>
<span class="sd">           [0., 0., 0., 0., 2.],</span>
<span class="sd">           [1., 0., 0., 0., 1.],</span>
<span class="sd">           [0., 2., 2., 0., 0.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">p_from_latent</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="n">rescale</span><span class="p">,</span> <span class="n">loops</span><span class="o">=</span><span class="n">loops</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">sample_edges</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">,</span> <span class="n">loops</span><span class="o">=</span><span class="n">loops</span><span class="p">)</span>

    <span class="c1"># check weight function</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">wt</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span>
        <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">wt</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">wt</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;You have not passed a function for wt.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">wt</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">wtargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wtargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">wts</span> <span class="o">=</span> <span class="n">wt</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">A</span><span class="p">)),</span> <span class="o">**</span><span class="n">wtargs</span><span class="p">)</span>
        <span class="n">A</span><span class="p">[</span><span class="n">A</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">wts</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">*=</span> <span class="n">wt</span>  <span class="c1"># type: ignore</span>
    <span class="k">return</span> <span class="n">A</span></div>


<span class="k">def</span> <span class="nf">p_from_latent</span><span class="p">(</span>
    <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">Y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">rescale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">loops</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gemerates a matrix of connection probabilities for a random graph</span>
<span class="sd">    based on a set of latent positions</span>

<span class="sd">    If only X is given, the P matrix is calculated as :math:`P = XX^T`</span>
<span class="sd">    If X and Y is given, then :math:`P = XY^T`</span>
<span class="sd">    These operations correspond to the dot products between a set of latent</span>
<span class="sd">    positions, so each row in X or Y represents the latent positions in</span>
<span class="sd">    :math:`\mathbb{R}^{num-columns}` for a single vertex in the random graph</span>
<span class="sd">    Note that this function may also rescale or clip the resulting P</span>
<span class="sd">    matrix to get probabilities between 0 and 1, or remove loops</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X: np.ndarray, shape (n_vertices, n_dimensions)</span>
<span class="sd">        latent position from which to generate a P matrix</span>
<span class="sd">        if Y is given, interpreted as the left latent position</span>

<span class="sd">    Y: np.ndarray, shape (n_vertices, n_dimensions) or None, optional</span>
<span class="sd">        right latent position from which to generate a P matrix</span>

<span class="sd">    rescale: boolean, optional (default=False)</span>
<span class="sd">        when rescale is True, will subtract the minimum value in</span>
<span class="sd">        P (if it is below 0) and divide by the maximum (if it is</span>
<span class="sd">        above 1) to ensure that P has entries between 0 and 1. If</span>
<span class="sd">        False, elements of P outside of [0, 1] will be clipped</span>

<span class="sd">    loops: boolean, optional (default=True)</span>
<span class="sd">        whether to allow elements on the diagonal (corresponding</span>
<span class="sd">        to self connections in a graph) in the returned P matrix.</span>
<span class="sd">        If loops is False, these elements are removed prior to</span>
<span class="sd">        rescaling (see above) which may affect behavior</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    P: ndarray (n_vertices, n_vertices)</span>
<span class="sd">        A matrix representing the probabilities of connections between</span>
<span class="sd">        vertices in a random graph based on their latent positions</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Sussman, D.L., Tang, M., Fishkind, D.E., Priebe, C.E.  &quot;A</span>
<span class="sd">       Consistent Adjacency Spectral Embedding for Stochastic Blockmodel Graphs,&quot;</span>
<span class="sd">       Journal of the American Statistical Association, Vol. 107(499), 2012</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">Y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">X</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Latent positions must be numpy.ndarray&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">Y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Latent positions must have dimension 2 (n_vertices, n_dimensions)&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dimensions of latent positions X and Y must be the same&quot;</span><span class="p">)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">X</span> <span class="o">@</span> <span class="n">Y</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># should this be before or after the rescaling, could give diff answers</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">loops</span><span class="p">:</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">P</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">P</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">rescale</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">P</span> <span class="o">-</span> <span class="n">P</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">P</span> <span class="o">/</span> <span class="n">P</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">P</span><span class="p">[</span><span class="n">P</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">P</span><span class="p">[</span><span class="n">P</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">P</span>


<div class="viewcode-block" id="mmsbm"><a class="viewcode-back" href="../../../reference/reference/simulations.html#graspologic.simulations.mmsbm">[docs]</a><span class="k">def</span> <span class="nf">mmsbm</span><span class="p">(</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">rng</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">Generator</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">loops</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Samples a graph from Mixed Membership Stochastic Block Model (MMSBM).</span>

<span class="sd">    MMSBM produces a graph given the specified block connectivity matrix B,</span>
<span class="sd">    which indicates the probability of connection between nodes based upon</span>
<span class="sd">    their community membership.</span>
<span class="sd">    Each node is assigned a membership vector drawn from Dirichlet distribution</span>
<span class="sd">    with parameter :math:`\vec{\alpha}`. The entries of this vector indicate the</span>
<span class="sd">    probabilities for that node of pertaining to each community when interacting with</span>
<span class="sd">    another node. Each node&#39;s membership is determined according to those probabilities.</span>
<span class="sd">    Finally, interactions are sampled according to the assigned memberships.</span>

<span class="sd">    Read more in the `Mixed Membership Stochastic Blockmodel (MMSBM) Tutorial</span>
<span class="sd">    &lt;https://microsoft.github.io/graspologic/tutorials/simulations/mmsbm.html&gt;`_</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n: int</span>
<span class="sd">        Number of vertices of the graph.</span>

<span class="sd">    p: array-like, shape (n_communities, n_communities)</span>
<span class="sd">        Probability of an edge between each of the communities, where ``p[i, j]``</span>
<span class="sd">        indicates the probability of a connection between edges in communities</span>
<span class="sd">        :math:`(i, j)`.</span>
<span class="sd">        0 &lt; ``p[i, j]`` &lt; 1 for all :math:`i, j`.</span>

<span class="sd">    alpha: array-like, shape (n_communities,)</span>
<span class="sd">        Parameter alpha of the Dirichlet distribution used</span>
<span class="sd">        to sample the mixed-membership vectors for each node.</span>
<span class="sd">        ``alpha[i]`` &gt; 0 for all :math:`i`.</span>

<span class="sd">    rng: numpy.random.Generator, optional (default = None)</span>
<span class="sd">        :class:`numpy.random.Generator` object to sample from distributions.</span>
<span class="sd">        If None, the random number generator is the Generator object constructed</span>
<span class="sd">        by ``np.random.default_rng()``.</span>

<span class="sd">    directed: boolean, optional (default=False)</span>
<span class="sd">        If False, output adjacency matrix will be symmetric. Otherwise, output adjacency</span>
<span class="sd">        matrix will be asymmetric.</span>

<span class="sd">    loops: boolean, optional (default=False)</span>
<span class="sd">        If False, no edges will be sampled in the diagonal. Otherwise, edges</span>
<span class="sd">        are sampled in the diagonal.</span>

<span class="sd">    return_labels: boolean, optional (default=False)</span>
<span class="sd">        If False, the only output is the adjacency matrix.</span>
<span class="sd">        If True, output is a tuple. The first element of the tuple is the adjacency</span>
<span class="sd">        matrix. The second element is a matrix in which the :math:`(i^{th}, j^{th})`</span>
<span class="sd">        entry indicates the membership assigned to node i when interacting with node j.</span>
<span class="sd">        Community 1 is labeled with a 0, community 2 with 1, etc.</span>
<span class="sd">        -1 indicates that no community was assigned for that interaction.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Airoldi, Edoardo, et al. Mixed Membership Stochastic Blockmodels.</span>
<span class="sd">       Journal of Machine Learning Research, vol. 9, 2008, pp. 19812014.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A: ndarray, shape (n, n)</span>
<span class="sd">        Sampled adjacency matrix</span>
<span class="sd">    labels: ndarray, shape (n, n), optional</span>
<span class="sd">        Array containing the membership assigned to each node when interacting with</span>
<span class="sd">        another node.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng(1)</span>
<span class="sd">    &gt;&gt;&gt; np.random.seed(1)</span>
<span class="sd">    &gt;&gt;&gt; n = 6</span>
<span class="sd">    &gt;&gt;&gt; p = [[0.5, 0], [0, 1]]</span>

<span class="sd">    To sample a binary MMSBM in which very likely all nodes pertain to community two:</span>

<span class="sd">    &gt;&gt;&gt; alpha = [0.05, 1000]</span>
<span class="sd">    &gt;&gt;&gt; mmsbm(n, p, alpha, rng = rng)</span>
<span class="sd">    array([[0., 1., 1., 1., 1., 1.],</span>
<span class="sd">           [1., 0., 1., 1., 1., 1.],</span>
<span class="sd">           [1., 1., 0., 1., 1., 1.],</span>
<span class="sd">           [1., 1., 1., 0., 1., 1.],</span>
<span class="sd">           [1., 1., 1., 1., 0., 1.],</span>
<span class="sd">           [1., 1., 1., 1., 1., 0.]])</span>

<span class="sd">    To sample a binary MMSBM similar to 2-block SBM with connectivity matrix B:</span>

<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng(1)</span>
<span class="sd">    &gt;&gt;&gt; np.random.seed(1)</span>
<span class="sd">    &gt;&gt;&gt; alpha = [0.05, 0.05]</span>
<span class="sd">    &gt;&gt;&gt; mmsbm(n, p, alpha, rng = rng)</span>
<span class="sd">    array([[0., 1., 0., 0., 0., 0.],</span>
<span class="sd">           [1., 0., 0., 0., 0., 0.],</span>
<span class="sd">           [0., 0., 0., 0., 0., 0.],</span>
<span class="sd">           [0., 0., 0., 0., 1., 1.],</span>
<span class="sd">           [0., 0., 0., 1., 0., 1.],</span>
<span class="sd">           [0., 0., 0., 1., 1., 0.]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">check_scalar</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;n&quot;</span><span class="p">,</span> <span class="n">target_type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">min_val</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ensure_2d</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">nx</span> <span class="o">!=</span> <span class="n">ny</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;p must be a square matrix, not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;There are non-numeric elements in p&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Values in p must be in between 0 and 1.&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="n">alpha_checked</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;alpha must not be None&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">alpha_checked</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">alpha_checked</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span>
            <span class="n">alpha_checked</span><span class="p">,</span> <span class="n">ensure_2d</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ensure_min_features</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">alpha_checked</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;There are non-numeric elements in alpha&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">alpha_checked</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Alpha entries must be &gt; 0.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">alpha_checked</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">),):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;alpha must be a list or np.array of shape </span><span class="si">{c}</span><span class="s2">, not </span><span class="si">{w}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">c</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">),),</span> <span class="n">w</span><span class="o">=</span><span class="n">alpha_checked</span><span class="o">.</span><span class="n">shape</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">Generator</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;rng must be &lt;class &#39;numpy.random.Generator&#39;&gt; not </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">rng</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">_rng</span> <span class="o">=</span> <span class="n">rng</span> <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">loops</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;loops is not of type bool.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">directed</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;directed is not of type bool.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">return_labels</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;return_labels is not of type bool.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">directed</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">p</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Specified undirected, but P is directed.&quot;</span><span class="p">)</span>

    <span class="c1"># Naming convention follows paper listed in references.</span>
    <span class="n">mm_vectors</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">dirichlet</span><span class="p">(</span><span class="n">alpha_checked</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="n">mm_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">mm_vectors</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">))</span>

    <span class="c1"># labels:(n,n) matrix with all membership indicators for initiators and receivers</span>
    <span class="c1"># instead of storing the indicator vector, argmax is directly computed</span>
    <span class="c1"># check docstrings for more info.</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">p_vector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span>
            <span class="n">_rng</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pvals</span><span class="o">=</span><span class="n">p_vector</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">),</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">mm_vectors</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">p</span><span class="p">[(</span><span class="n">labels</span><span class="p">,</span> <span class="n">labels</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">sample_edges</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">,</span> <span class="n">loops</span><span class="o">=</span><span class="n">loops</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">loops</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_labels</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">A</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>